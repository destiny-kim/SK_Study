## 아핀 결합
일반적으로 아핀 공간에서는 점 + 이동벡터만 가능한데,  
일정 조건에선 점 + 점으로도 점의 이동을 구현할 수 있다.  
P1(a, b, 1), P2(c, d, 1)가 있을 때, 각 점에 스칼라 A, B를 곱하면 차원이 1을 넘어가지 않게 조절할 수 있다.  
A * P1 + B * P2  
=> (A*a + B*c, A*b + B*d, A+B)  
즉 여기서 A+B = 1이면 된다 => B = A - 1  
=> L(A) = A * P1 + (1 - A) * P2  라는 방정식으로 표현된다.  


### 벡터를 모니터의 점으로 그릴 때
1. 가장 큰 차이는 모니터에선 y축이 아래를 향한다
2. 정수만을 사용한다

그래서 실수를 사용하는 데카르트 좌표계 벡터 -> 모니터의 픽셀로 변환시, 벡터는 어느 픽셀을 골라야 할지 결정해야 한다.  
책에서는 이와 관련된 2가지 알고리즘을 소개했다.  

### 브레젠험 알고리즘
[참고](https://playground10.tistory.com/62)  
실수 벡터를 정수 픽셀로 변환할 때, 어느 픽셀을 고를지 결정하는 알고리즘  

데카르트 좌표계의 기울기가 양수인 직선을 기준으로, 이동해야 할 벡터 (x, y)를 비교한다.  
벡터가 그리는 직선의 기울기는 양수라 가정한다.  

1. x를 1만큼 이동  
그럼 y는 y 또는 y+1 중 하나가 될 것이다. (기울기가 양수이므로)  
이를 찾기 위해 y+0.5 (중단점)을 사용한다.  
2. (x+1, y+0.5)가 직선보다 위이면 (x+1, y)로 결정 / 아래이면 (x+1, y+1)로 결정  
3. 1의 과정을 반복

이것을 일반화하면 다음과 같다.  

![image](https://github.com/yooonmyong/SK_Study/assets/40621689/160dd01d-db7c-4e11-bd46-7967dca77064)  
직선의 방정식 y = ax + b을 떠올려보면,  
우리는 모니터에 직선을 그리는 것이므로 좌표계의 범위가 너비(w), 높이(h)로 정해져있고 이를 a에 넣을 수 있다. (직선의 기울기는 결국 y값의 증가량/x값의 증가량 이므로)  
w = xr - xl  
h = yr - yl  
y = (h/w)x + b  
y절편 b는 (xl, yl)을 넣었다고 가정했을 때 b = yl - (h/w)xl가 되는데, 이를 다시 방정식에 넣으면 아래와 같다.  
```
y = (h/w)x + yl - (h/w)xl

그리고 앞의 1~3의 과정을 위 식으로 표현하면
y > (h/w)x + yl - (h/w)xl  -> 직선보다 위에 있는 점
=> (h/w)x + yl - (h/w)xl - y < 0
=> h(x - xl) + w(yl - y) < 0

y < (h/w)x + yl - (h/w)xl  -> 직선보다 아래에 있는 점
=> (h/w)x + yl - (h/w)xl - y > 0
=> h(x - xl) + w(yl - y) > 0
```

이 식을 F라는 함수로 보고, 앞의 1~3 과정을 다시 해보면..  

F(x, y)  
F1은 (x+1, y+0.5)을 넣었을 때 h(x+1 - xl) + w(yl - y+0.5) < 0, > 0을 판별  
F2는 케이스가 2가지인데,  
1. F1 < 0 (직선 위)  
F2의 중단점은 (x+2, y+0.5)이 됨  
h(x+2 - xl) + w(yl - y+0.5) < 0, > 0을 판별  
**위 F1식에 +h하면 F2가 된다**
```
F2 = F1 + h
```

3. F1 > 0 (직선 아래)  
F2의 중단점은 (x+2, y+1.5)가 됨  
h(x+2 - xl) - w(y+1.5 - yl) < 0, > 0을 판별  
**위 F1식에 +(h-w)하면 F2가 된다**  
```
F2 = F1 + h - w
```

식 정리를 위해 F(xl, yl)  
F1(xl + 1, yl + 0.5) = h(xl + 1 - xl) - w(yl + 0.5 - yl)  
F1 = h - 0.5w  
정수로 만들기 위해 2를 곱하면..  
**F1 = 2h - w**  
F2(xl + 2, yl + 0.5) = h(xl + 2 - xl) - w(yl + 0.5 - yl)  
F2 = 2h - 0.5w  
**F2 = 4h - w**  
F2(xl + 2, yl + 1.5) = h(xl + 2 - xl) - w(yl + 1.5 - yl)  
F2 = 2h - 1.5w  
**F2 = 4h - 3w**  

위 식은 아래처럼 일반화할 수 있다!  
```
<초기식>
F1 = 2h - w

<Fn>
F1이 직선 위에 있을 경우
F2 = F1 + 2h

F1이 직선 아래에 있을 경우
F2 = F1 + 2h - 2w
```

### 라인 클리핑
브레젠험 알고리즘이 선을 그리는 알고리즘이라면, 클리핑은 모니터에서 직선의 안 보이는 부분을 잘라내는 알고리즘이다.  

1. 모니터 화면 면적을 기준으로 직선의 시작점과 끝점 위치가 화면 외부인지 내부인지를 판별한다. 이를 각각 4자리 비트로 표현한다.
```
4자리 비트는 0000으로 초기화함
모니터 화면을 (-x1, -y1) ~ (+x1, +y1) 으로 가정함

픽셀의 x좌표가
-x1보다 작음 -> _ _ 0 1
x1보다 큼    -> _ _ 1 0

픽셀의 y좌표가
-y1보다 작음 -> 0 1 _ _
y1보다 큼    -> 1 0 _ _ 
```
2. 두 점의 4자리 비트가 0000일 경우 해당 픽셀을 그린다. (모니터 내 점)
3. 아닐 경우 두 점의 비트를 &연산한다.
4. &연산 결과가 0000이 아니면 점을 그리지 않는다. (모니터 외 점)
5. &연산 결과가 0000이면 시작점, 끝점 이동(클리핑) 후 1의 과정을 반복한다.

#### 예제문제
![image](https://github.com/yooonmyong/SK_Study/assets/40621689/fe453682-04df-40e0-8742-0e9749f879e9)  
[참고](https://www.youtube.com/watch?v=U2OSzGKXo3A)  
A(50, 10), B(50, 40), C(80, 40), D(80, 10)의 모니터가 있고, 이 모니터 위에 직선을 그리려 한다.  
직선의 시작점 P1(70, 20), 끝점 P2(100, 10)일 때 해당 직선을 그려보자.  

### (+) DDA 알고리즘
