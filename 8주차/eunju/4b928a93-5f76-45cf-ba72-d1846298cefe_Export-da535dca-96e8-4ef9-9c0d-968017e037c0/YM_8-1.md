# 게임엔진
게임은 가상 공간에 다양한 물체를 배치하고, 이를 플레이어가 탐험할 수 있는 형태로 제공한다.  
게임의 자원(리소스, 에셋)을 공간(씬, 레벨)에 담아 관리할 수 있는 인터페이스를 제공한다  
게임엔진은 씬 단위로 이를 관리하여 게임 화면을 구성한다.  

# 게임오브젝트
개발자가 게임 화면을 구성할 때 필요한 규격이다. (물체, 리소스를 담는 작은 그릇 개념)  
이 게임오브젝트의 공간상 배치 정보를 담는 것이 트랜스폼이다.  
트랜스폼은 크기, 회전, 이동 3가지로 구성된다.  

개발자가 씬에 게임오브젝트를 배치하면, 게임엔진이 이를 렌더링한다.  
이때 게임오브젝트의 트랜스폼 정보가 사용되는데, 모델링행렬을 사용해 게임오브젝트 내 물체의 버텍스를 반환한다.  

# 모델링 행렬 설계
우선 트랜스폼의 구성요소 3가지는 각각 아핀행렬에 대응된다.  
**이동행렬(T)**  
![image](https://github.com/yooonmyong/SK_Study/assets/40621689/41da106e-83f8-4624-afc6-701fff51ff86)  
**크기행렬(S)**  
![image](https://github.com/yooonmyong/SK_Study/assets/40621689/7c95b44c-4b6c-494e-9e08-08157e0a7347)  
**회전행렬(R)**  
![image](https://github.com/yooonmyong/SK_Study/assets/40621689/ef934370-3161-46a7-b3d8-23c76835bed2)  

행렬 곱의 성질을 사용하면, 이들 3가지 기능을 모두 수행하는 하나의 행렬을 만들 수 있다.  
다만 행렬 곱은 교환법칙이 성립하지 않아 곱하는 순서에 따라 완전히 다른 행렬이 나온다.  

위 행렬을 곱하는 순서에 따라 총 6가지 모델링 행렬이 나올 수 있다.  
1. T * S * R
2. T * R * S
3. S * T * R
4. S * R * T
5. R * T * S
6. R * S * T

이중 어느 순서로 곱해야 개발자가 의도한 대로 물체의 버텍스를 반환할 수 있을까?  
정사각형 물체를 45도 회전한 후 (0, 1)로 이동시킨다고 가정한다.  

![image](https://github.com/yooonmyong/SK_Study/assets/40621689/d48e9e08-d9f3-47fc-9382-18b4942faaae)  
이동/회전변환을 우선 살펴봤을 때, (b)처럼 이동 후 회전을 적용할 경우 물체의 이동이 의도한 것처럼 (0, 1)로 이동하지 않는다.  

![image](https://github.com/yooonmyong/SK_Study/assets/40621689/4e9a902b-0a23-47a4-8154-017d374f81cb)  
크기/회전변환의 경우도 무엇을 먼저 적용하는지에 따라 결과가 달라진다.  

즉 회전이 이동의 영향을 받고, 크기와 회전이 서로 영향을 받는다.  
이때 회전행렬은 강체변환 성질을 갖고 있어 물체의 형태를 보존한다.  
그래서 크기행렬로 물체의 크기를 결정한 후, 회전을 적용하면 개발자의 의도대로 물체를 이동할 수 있다.  

∴ 크기 - 회전 - 이동 순으로 모델링 행렬을 생성하면, 물체를 의도대로 이동시킬 수 있다. (T * R * S)  

# 로컬 공간
물체의 정보를 담기 위해 있는 공간  
물체마다 갖는 개별 공간이며, 물체를 렌더링할 때 필요한 메시데이터를 담는 공간이다.  

# 로컬 축
물체의 위치 외에 물체가 바라보는 방향도 필요한데, 이를 '로컬 축' 이란 정보로 제공한다.  
로컬 축은 물체의 회전에만 영향받는다.  
그래서 로컬축 좌표도 { (cos, sin), (-sin, cos) } 처럼 회전행렬의 형태로 표현된다.  

# 월드 공간
씬은 여러 물체를 배치하는 공간이기 때문에, 모든 물체를 한 번에 관리하는 공간이 필요하다.  
이를 월드공간이라 부른다.  

# 리소스 관리
리소스의 경우, 여러 물체가 동일 리소스를 사용하는 경우가 많다.  
이때 물체마다 리소스 데이터를 들고있을 경우 관리 측면에서 비효율적이다.  
그래서 리소스는 하나의 저장소에서 관리하고, 저장소에서 리소스마다 key를 부여해 물체는 이 key를 참조하도록 관리한다.  

